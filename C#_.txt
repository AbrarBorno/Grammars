
Grammer:= CSharp
{
//  AB.Grammar
//  This appendix contains summaries of the lexical and syntactic grammars found in the main document, and of the grammar
//  extensions for unsafe code. Grammar productions appear here in the same order that they appear in the main document.



//  AC.   Lexical grammar
input              ::=  input-section?
input-section      ::=  input-section-part+
input-section-part ::=  ( input-elements?  new-line )  |  pp-directive
input-elements     ::=  input-element+
input-element      ::=  ( ws | comment | token )

// AD.Line terminators
new-line  ::=  !< Carriage return character (U+000D) >!
             | !< Line feed character (U+000A) >!
             | !< Carriage return character (U+000D) followed by line feed character (U+000A) >!
             | !< Next line character (U+0085) >!
             | !< Line separator character (U+2028) >!
             | !< Paragraph separator character (U+2029) >!

//  AE.   Comments
            comment ::=  single-line-comment  |  delimited-comment
single-line-comment ::=  "//"

//   input-characters?
input-characters   ::=  input-character+
input-character    ::=  !< Any Unicode character except a new-line-character >!
new-line-character ::=  ( !< Carriage return character (U+000D)  >!
                         | !< Line feed character (U+000A)  >!
                         | !< Next line character (U+0085)  >!
                         | !< Line separator character (U+2028)  >!
                         | !< Paragraph separator character (U+2029)  >!
                        )
delimited-comment         ::=  "/*" delimited-comment-text? asterisks '/'
delimited-comment-text    ::=  delimited-comment-section | ( delimited-comment-text delimited-comment-section )
delimited-comment-section ::=  '/' | ( asterisks? not-slash-or-asterisk )
asterisks                 ::=  '*'+
not-slash-or-asterisk     ::=  !< Any Unicode character except / or *   >!

//  AF.   White space
ws ::= (  !< Any character with Unicode class Zs   >!
        | !< Horizontal tab character (U+0009)     >!
        | !< Vertical tab character (U+000B)       >!
        | !< Form feed character (U+000C)          >!
       )
//  AG.   Tokens
token  ::= ( identifier | keyword | integer-literal | real-literal | character-literal | string-literal | operator-or-punctuator )

//  AH.   Unicode character escape sequences
four-hex-digits         ::=  hex-digit hex-digit hex-digit hex-digit
unicode-escape-sequence ::=  ( "\u" four-hex-digits ) | ( "\U"  four-hex-digits four-hex-digits )

//  AI.   Identifiers
identifier                 ::=  available-identifier  |  ( '@' identifier-or-keyword )
available-identifier       ::=  !< An identifier-or-keyword that is not a keyword  >!
identifier-or-keyword      ::=  identifier-start-character   identifier-part-characters?
identifier-start-character ::=  letter-character  |  '_'

// (the underscore character U+005F)
identifier-part-characters  ::=  identifier-part-character+
identifier-part-character   ::=  letter-character | decimal-digit-character | connecting-character | combining-character | formatting-character
         letter-character   ::=  !< A Unicode character of classes Lu, Ll, Lt, Lm, Lo, or Nl  >!
                               | !< A unicode-escape-sequence representing a character of classes Lu, Ll, Lt, Lm, Lo, or Nl  >!
      combining-character   ::=  !< A Unicode character of classes Mn or Mc >!
                               | !< A unicode-escape-sequence representing a character of classes Mn or Mc  >!
  decimal-digit-character   ::=  !< A Unicode character of the class Nd >
                               |   !< A unicode-escape-sequence representing a character of the class Nd  >!
     connecting-character   ::=  !< A Unicode character of the class Pc >!
                               |   !< A unicode-escape-sequence representing a character of the class Pc  >!
     formatting-character   ::=  !< A Unicode character of the class Cf >!
                               |   !< A unicode-escape-sequence representing a character of the class Cf  >!

//  AJ.   Keywords
keyword  ::= (  abstract | as       | base     | bool     | break     | byte     | case   | catch      | char      | checked
              | class    | const    | continue | decimal  | default   | delegate | do     | double     | else      | enum
              | event    | explicit |	extern   | false    | finally   | fixed    | float  |	for        | foreach   | goto
              | if       | implicit |	in       | int      | interface | internal | is	    | lock	     | long	     | namespace
              | new      | null     | object   | operator |	out       | override | params | private    | protected | public
              | readonly | ref      | return   | sbyte    | sealed    | short    | sizeof |	stackalloc | static    | string
              | struct   | switch   | this     | throw    |	true      | try      | typeof |	uint       | ulong     | unchecked
              | unsafe   | ushort   | using    | virtual  |	void      | volatile | while
             )
//  AK.   Literals
     dg  ::=  '"'
     sq  ::=  '''
literal  ::=  ( boolean-literal | integer-literal | real-literal | character-literal | string-literal | null-literal )

boolean-literal              ::=  "true" | "false"
integer-literal              ::=  decimal-integer-literal | hexadecimal-integer-literal
decimal-integer-literal      ::=  decimal-digits integer-type-suffix?
decimal-digits               ::=  decimal-digit+
decimal-digit                ::=  '0'-'9'
integer-type-suffix          ::=  ( 'U' | 'u' | 'L' | 'l' | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu" )
hexadecimal-integer-literal  ::=  '0' ( 'x' | 'X' )    hex-digits   integer-type-suffix?
hex-digits                   ::=  hex-digit+
hex-digit                    ::= ( ('0'-'9') | ('A'-'F') | ('a'-'f') )
real-literal                 ::= ( ( decimal-digits '.' decimal-digits exponent-part? real-type-suffix? )
                                  | ( '.' decimal-digits exponent-part? real-type-suffix? )
                                  | ( decimal-digits exponent-part real-type-suffix? )
                                  | ( decimal-digits real-type-suffix )
                                 )
exponent-part                ::=  ( 'e' | 'E')   sign?   decimal-digits
sign                         ::=  '+' | '-'
real-type-suffix             ::=  ( 'F' | 'f' | 'D' | 'd' | 'M' | 'm' )
character-literal            ::=  sq character  sq
character                    ::= ( single-character | simple-escape-sequence | hexadecimal-escape-sequence | unicode-escape-sequence )

single-character                  ::=  !< Any character except ' (U+0027), \ (U+005C), and new-line-character >!
simple-escape-sequence            ::=  '\' ( sq | dq | '\' | '0' | 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' )
hexadecimal-escape-sequence       ::=  "\x" hex-digit hex-digit? hex-digit? hex-digit?
string-literal                    ::=  regular-string-literal  |  verbatim-string-literal
regular-string-literal            ::=  dq regular-string-literal-characters? dg
regular-string-literal-characters ::=  regular-string-literal-character+
regular-string-literal-character  ::= (  single-regular-string-literal-character | simple-escape-sequence
                                       | hexadecimal-escape-sequence             | unicode-escape-sequence
                                      )
single-regular-string-literal-character   ::=  !< Any character except " (U+0022), \ (U+005C), and new-line-character >!
verbatim-string-literal_op                ::=  '@' dq
verbatim-string-literal                   ::=  verbatim-string-literal-op verbatim-string-literal-characters? dq
verbatim-string-literal-characters        ::=  verbatim-string-literal-character+
verbatim-string-literal-character         ::=  single-verbatim-string-literal-character  |  quote-escape-sequence
single-verbatim-string-literal-character  ::=  !< any character except "  >!
quote-escape-sequence                     ::=  dq dq
null-literal                              ::=  "null"


//  AL.   Operators and punctuators
operator-or-punctuator ::= (  '{' | '}' | '[' | ']' | '(' | ')' | '.' | ',' | ':' | ';' | '+' | '-'
                            | '*' | '/' | '%' | '&' | '|' | '^' | '!' | '~' | '=' | '<' | '>' | '?' |
                            |	"??" | "::" | "++" | "--" | "&&" | "||" | "->" | "==" | "!=" | "<=" |	">="
                            | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<" | "=>" | "<<="
                           )
right-shift             ::=  ">|>"
right-shift-assignment  ::=  ">|>="

//  AM.   Pre-processing directives
conditional-symbol   ::=  !< Any identifier-or-keyword except true or false >!
pp-header            ::=  ( ws? '#' ws? )
pp-footer            ::=  ( pp-new-line conditional-section? )
pp-cond-symbol       ::=  ( ws conditional-symbol pp-new-line )
pp-directive         ::=  pp-declaration  |  pp-conditional  |  pp-line  |  pp-diagnostic |  pp-region  |   pp-pragma
pp-expr              ::=  ws?  pp-or-expr  ws?
pp-or-expr           ::=  pp-and-expr    | ( pp-or-expr  ws? "||" ws? pp-and-expr   )
pp-and-expr          ::=  pp-eq-expr     | ( pp-and-expr ws? "&&" ws? pp-eq-expr    )
pp-eq-expr           ::=  pp-unary-expr  | ( pp-eq-expr  ws? "==" ws? pp-unary-expr )
                                         | ( pp-eq-expr  ws? "!=" ws? pp-unary-expr )
pp-unary-expr        ::=  pp-primary-expr  |   ( '!' ws? pp-unary-expr )
pp-primary-expr      ::=  ( true | false  |  conditional-symbol  | ( '(' ws? pp-expr ws? ')' ) )
pp-declaration       ::=  pp-header ( define | undef )  pp-cond-symbol
pp-new-line          ::=  ws?   single-line-comment?   new-line
pp-conditional       ::=  pp-if-section   pp-elif-sections?   pp-else-section?   pp-endif
pp-if-section        ::=  pp-header  if  ws  pp-expr  pp-new-line  conditional-section?
pp-elif-sections     ::=  pp-elif-section+
pp-elif-section      ::=  ( pp-header elif ws pp-expr pp-footer )
pp-else-section      ::=  ( pp-header else            pp-footer )
pp-endif             ::=  ( pp-header endif  pp-new-line )
pp-diagnostic        ::=  pp-header ( error | warning )  pp-message
pp-message           ::=  new-line | ( ws input-characters? new-line )
pp-region            ::=  pp-start-region conditional-section? pp-end-region
pp-start-region      ::=  pp-header region    pp-message
pp-end-region        ::=  pp-header endregion pp-message
pp-line              ::=  pp-header line ws line-indicator pp-new-line
pp-pragma            ::=     pp-header pragma   ws   pragma-body   pp-new-line
conditional-section  ::=  input-section  |  skipped-section
skipped-section      ::=  skipped-section-part+
skipped-section-part ::=  ( skipped-characters? new-line )  |  pp-directive
skipped-characters   ::=  ws? not-number-sign input-characters?
not-number-sign      ::=  !< Any input-character except # >!
line-indicator       ::=  ( ( decimal-digits ws file-name )  |  decimal-digits  |  default  |  hidden )
file-name            ::=  dq file-name-characters dq
file-name-characters ::=  file-name-character+
file-name-character  ::=  !< Any input-character except " >!
pragma-body          ::=  pragma-warning-body
pragma-warning-body  ::=  ( warning ws warning-action ) ( ws warning-list )?
warning-action       ::=  disable | restore
warning-list         ::=  decimal-digits ( ws-comma-ws  decimal-digits )*
ws-comma-ws          ::=  ( ws? ',' ws? )

//  AN.   Syntactic grammar



//  AO.   Basic concepts

namespace-name          ::=  namespace-or-type-name
type-name               ::=  namespace-or-type-name
namespace-or-type-name  ::=  ( ( identifier type-argument-list? ) | ( namespace-or-type-name '.' identifier type-argument-list? ) | qualified-alias-member )

//  AP.   Types

type                      ::=  ( value-type  | reference-type | type-parameter )
value-type                ::=  ( struct-type | enum-type )
struct-type               ::=  ( type-name   | simple-type | nullable-type )
simple-type               ::=  ( numeric-type | bool )
numeric-type              ::=  ( integral-type | floating-point-type | decimal )
integral-type             ::=  ( sbyte | byte | short | ushort | int | uint | long | ulong | char )
floating-point-type       ::=  ( float | double )
nullable-type             ::=  ( non-nullable-value-type '?' )
non-nullable-value-type   ::=  type
enum-type                 ::=  type-name
reference-type::=         ::=  ( class-type | interface-type | array-type | delegate-type )
class-type                ::=  ( type-name | object | dynamic | string )
interface-type            ::=  type-name
rank-specifiers           ::=  rank-specifier+
rank-specifier            ::=  ( '['   dim-separators?   ']' )
dim-separators            ::=  ','+
delegate-type             ::=  type-name
type-argument-list        ::=  ( '<'   type-arguments   '>' )
type-arguments            ::=  ( type-argument  ( ',' type-argument )* )
type-argument             ::=  type
type-parameter            ::=  identifier


//  AQ.   Variables

variable-reference  ::=   expr



//  AR.   exprs

// -- argument
argument-list   ::=  ( argument ( ',' argument )* )
argument        ::=  ( argument-name? argument-value )
argument-name   ::=  ( identifier ':' )
argument-value  ::=  ( expr | ( ref variable-reference ) | ( out variable-reference ) )
// -- primary
                 primary-expr  ::=  primary-no-array-creation-expr | array-creation-expr
primary-no-array-creation-expr ::=(  literal                        | simple-name
                                   | parenthesized-expr             | member-access
                                   | invocation-expr                | element-access
                                   | this-access                    | base-access
                                   | post-increment-expr            | post-decrement-expr
                                   | object-creation-expr           | delegate-creation-expr
                                   | anonymous-object-creation-expr | typeof-expr
                                   | checked-expr                   | unchecked-expr
                                   | default-value-expr             | anonymous-method-expr
                                  )
          simple-name  ::=  identifier type-argument-list?
   parenthesized-expr  ::=  '(' expr ')'
        member-access  ::= (  ( primary-expr '.' identifier type-argument-list? )
                            | ( predefined-type        '.' identifier type-argument-list? )
                            | ( qualified-alias-member '.' identifier )
                           )
      predefined-type  ::= ( bool | byte | char | decimal | double | float | int | long | object | sbyte | short | string |	uint | ulong | ushort )
      invocation-expr  ::=  primary-expr '(' argument-list? ')'
       element-access  ::=  primary-no-array-creation-expr '[' argument-list ']'
          this-access  ::=  this
          base-access  ::=  ( base '.' identifier )  |  ( base '[' argument-list ']' )
  post-increment-expr  ::=  primary-expr "++"
  post-decrement-expr  ::=  primary-expr "--"
                 args  ::=  '(' argument-list ')'
 object-creation-expr  ::=   ( new type args object-or-collection-initializer? )
                          |  ( new type object-or-collection-initializer )

 object-or-collection-initializer  ::=     ( object-initializer | collection-initializer )

       object-initializer       ::=  ( '{' member-initializer-list? '}' )  |  ( '{' member-initializer-list ',' '}' )
       member-initializer-list  ::=  member-initializer ( ',' member-initializer )*
       member-initializer       ::=  identifier '=' initializer-value
              initializer-value ::=     expr | object-or-collection-initializer
   collection-initializer       ::=  '{' element-initializer-list ','? '}'
      element-initializer-list  ::=  element-initializer ( ',' element-initializer )*
      element-initializer       ::=  non-assignment-expr  |  ( '{' expr-list '}' )
                     expr-list  ::=     expr ( ',' expr )*
           array-creation-expr  ::= ( ( new non-array-type '[' expr-list ']' rank-specifiers? array-initializer? )
                                     | ( new array-type     array-initializer )
                                     | ( new rank-specifier array-initializer )
                                    )
        delegate-creation-expr  ::=  new   delegate-type   '('   expr   ')'
anonymous-object-creation-expr  ::=  new anonymous-object-initializer
anonymous-object-initializer    ::=  ( '{' member-declarator-list? '}' ) | ( '{' member-declarator-list ',' '}' )
      member-declarator-list  ::=  member-declarator ( ',' member-declarator )*
           member-declarator  ::=  simple-name | member-access | ( identifier '=' expr )
                 typeof-expr  ::=  typeof  '(' ( type | unbound-type-name | void ) ')'
           unbound-type-name  ::=  ( ( identifier generic-dimension-specifier? )
                                    | ( identifier "::" identifier generic-dimension-specifier? )
                                    | ( unbound-type-name '.' identifier generic-dimension-specifier? )
                                   )
 generic-dimension-specifier  ::=  '<' commas? '>'


                commas  ::=     ','+
          checked-expr  ::=    checked '(' expr ')'
        unchecked-expr  ::=  unchecked '(' expr ')'
    default-value-expr  ::=  default   '(' type ')'
            unary-expr  ::= (        primary-expr | ( '+' unary-expr ) | ( '-' unary-expr ) | ( '!' unary-expr ) | ( '~' unary-expr )
                             | pre-increment-expr | pre-decrement-expr | cast-expr
                            )
    pre-increment-expr  ::=  "++" unary-expr
    pre-decrement-expr  ::=  "--" unary-expr
             cast-expr  ::=  '(' type ')' unary-expr
   multiplicative-expr  ::=  (  unary-expr | ( multiplicative-expr '*' unary-expr )
                              | ( multiplicative-expr '/' unary-expr )
                              | ( multiplicative-expr '%' unary-expr )
                             )
        additive-expr  ::=  ( multiplicative-expr | ( additive-expr '+' multiplicative-expr ) | ( additive-expr '–' multiplicative-expr ) )
           shift-expr  ::=  ( additive-expr | ( shift-expr    "<<"     additive-expr ) | ( shift-expr right-shift additive-expr )
      relational-expr  ::=  (    shift-expr | ( relational-expr '<'  shift-expr ) | ( relational-expr '>'  shift-expr )
                                            | ( relational-expr "<=" shift-expr ) | ( relational-expr ">=" shift-expr )
                                            | ( relational-expr "is" type       ) | ( relational-expr "as" type       ) )
        equality-expr  ::=  ( relational-expr | ( equality-expr "==" relational-expr ) | ( equality-expr "!=" relational-expr ) )
             and-expr  ::=  equality-expr | ( and-expr '&' equality-expr )
    exclusive-or-expr  ::=  and-expr | ( exclusive-or-expr '^' and-expr )
    inclusive-or-expr  ::=  exclusive-or-expr | ( inclusive-or-expr '|' exclusive-or-expr )
 conditional-and-expr  ::=  inclusive-or-expr | ( conditional-and-expr "&&" inclusive-or-expr )
  conditional-or-expr  ::=  conditional-and-expr | (  conditional-or-expr "||" conditional-and-expr )
 null-coalescing-expr  ::=  conditional-or-expr  | (  conditional-or-expr "??" null-coalescing-expr )
     conditional-expr  ::=  null-coalescing-expr | ( null-coalescing-expr '?'  expr ':' expr )
          lambda-expr  ::=  anonymous-function-signature "=>" anonymous-function-body
anonymous-method-expr  ::=  delegate explicit-anonymous-function-signature? block


              anonymous-function-signature  ::=  explicit-anonymous-function-signature | implicit-anonymous-function-signature
     explicit-anonymous-function-signature  ::=  '('   explicit-anonymous-function-parameter-list?   ')'
explicit-anonymous-function-parameter-list  ::=  explicit-anonymous-function-parameter ( ',' explicit-anonymous-function-parameter )*
     explicit-anonymous-function-parameter  ::=  anonymous-function-parameter-modifier? type identifier
     anonymous-function-parameter-modifier  ::=  ref | out
     implicit-anonymous-function-signature  ::=  ( '(' implicit-anonymous-function-parameter-list? ')' )  | implicit-anonymous-function-parameter
implicit-anonymous-function-parameter-list  ::=  implicit-anonymous-function-parameter ( ',' implicit-anonymous-function-parameter )*
     implicit-anonymous-function-parameter  ::=  identifier

// LINQ
anonymous-function-body  ::=  expr | block
query-expr               ::=  from-clause query-body
from-clause              ::=  from type? identifier in expr
query-body               ::=  query-body-clauses? select-or-group-clause query-continuation?
query-body-clauses       ::=  query-body-clause+
query-body-clause        ::=  ( from-clause | let-clause | where-clause | join-clause | join-into-clause | orderby-clause )
let-clause               ::=  ( let identifier '=' expr )
where-clause             ::=  where boolean-expr
join-clause              ::=  join type? identifier in expr on expr equals expr
join-into-clause         ::=  join-clause into identifier
orderby-clause           ::=  ( orderby orderings )
orderings                ::=  ( ordering ( ',' ordering )* )
ordering                 ::=  expr ordering-direction?
ordering-direction       ::=  ascending     | descending
select-or-group-clause   ::=  select-clause | group-clause
select-clause            ::=  select expr
group-clause             ::=  group expr by expr
query-continuation       ::=  into identifier query-body
assignment               ::=  unary-expr assignment-operator expr
assignment-operator      ::=  ( '=' | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | right-shift-assignment )
expr                     ::=  non-assignment-expr | assignment
non-assignment-expr      ::=  ( conditional-expr    | lambda-expr | query-expr )
constant-expr            ::=  expr
boolean-expr             ::=  expr



//  AS.   Statements

                 statement  ::=  labeled-statement | declaration-statement  | embedded-statement
        embedded-statement  ::= (  block | empty-statement | expr-statement | selection-statement | iteration-statement | jump-statement
                                 | try-statement | checked-statement | unchecked-statement | lock-statement | using-statement | yield-statement )
                     block  ::=  '{' statement-list? '}'
            statement-list  ::=  statement+
           empty-statement  ::=  ';'
         labeled-statement  ::=  identifier ':' statement
     declaration-statement  ::=  ( local-variable-declaration | local-constant-declaration ) ';'
local-variable-declaration  ::=  local-variable-type   local-variable-declarators
local-variable-type         ::=  type  |   var
local-variable-declarators  ::=  local-variable-declarator ( ',' local-variable-declarator )*
local-variable-declarator   ::=  identifier ( '=' local-variable-initializer )?
local-variable-initializer  ::=  expr  |   array-initializer
local-constant-declaration  ::=  const type constant-declarators
      constant-declarators  ::=  constant-declarator ( ',' constant-declarator )*
      constant-declarator   ::=  identifier '=' constant-expr
           expr-statement   ::=  statement-expr ';'
           statement-expr   ::= (  invocation-expr | object-creation-expr | assignment | post-increment-expr | post-decrement-expr
                                 | pre-increment-expr | pre-decrement-expr )
// -- selection
 selection-statement  ::=  if-statement | switch-statement
// -- if else
        if-statement  ::=  if '(' boolean-expr ')' embedded-statement else-statement?
      else-statement  ::=  else embedded-statement

// -- switch
    switch-statement  ::=  switch '(' expr ')' switch-block
    switch-block      ::=  '{' switch-sections? '}'
    switch-sections   ::=  switch-section+
    switch-section    ::=  switch-labels statement-list
    switch-labels     ::=  switch-label+
    switch-label      ::=  ( case constant-expr ':' ) | ( default ':' )

// -- iteration
  iteration-statement ::= ( while-statement | do-statement | for-statement | foreach-statement )
      while-statement ::=  while '(' boolean-expr ')' embedded-statement
         do-statement ::=  do embedded-statement while '(' boolean-expr  ')'   ';'

// -- for
      for-statement   ::=  for '(' for-initializer? ';' for-condition? ';' for-iterator? ')' embedded-statement
      for-initializer ::=  local-variable-declaration | statement-expr-list
      for-condition   ::=  boolean-expr
      for-iterator    ::=  statement-expr-list
 statement-expr-list  ::=  statement-expr ( ',' statement-expr )*
 foreach-statement    ::=  foreach '(' local-variable-type identifier in expr ')' embedded-statement

// -- jumps
    jump-statement    ::=  ( break-statement | continue-statement | goto-statement | return-statement | throw-statement )
   break-statement    ::=  break ';'
continue-statement    ::=  continue   ';'
    goto-statement    ::=  ( ( goto identifier ';' ) | ( goto case constant-expr ';' ) | ( goto default ';' ) )
  return-statement    ::=  return expr? ';'
   throw-statement    ::=  throw  expr? ';'

// -- try block
          try-statement ::=  ( ( try block catch-clauses ) | ( try block finally-clause ) | ( try block catch-clauses finally-clause )
          catch-clauses ::=  ( specific-catch-clauses  general-catch-clause? ) | ( specific-catch-clauses? general-catch-clause  )
 specific-catch-clauses ::=  specific-catch-clause+
 specific-catch-clause  ::=  catch '(' class-type identifier? ')' block
  general-catch-clause  ::=  catch block
        finally-clause  ::=  finally block

// -- checked
     checked-statement  ::=    checked block
   unchecked-statement  ::=  unchecked block
        lock-statement  ::=  lock '(' expr ')' embedded-statement
       using-statement  ::=  using '(' resource-acquisition ')' embedded-statement
  resource-acquisition  ::=  local-variable-declaration  |  expr
       yield-statement  ::=  ( yield return  expr ';' ) | ( yield break ';' )

//  AT.   Namespaces
            compilation-unit  ::= ( extern-alias-directives? using-directives? global-attributes? ) | namespace-member-declarations?
        namespace-declaration ::= namespace qualified-identifier namespace-body ';'?
         qualified-identifier ::= identifier ( '.' identifier )+
               namespace-body ::= '{' extern-alias-directives? using-directives? namespace-member-declarations? '}'
      extern-alias-directives ::=  extern-alias-directive+
      extern-alias-directive  ::=  extern alias identifier ';'
// -- using diectives
             using-directives ::=  using-directive+
             using-directive  ::=  using-alias-directive | using-namespace-directive
       using-alias-directive  ::=  using identifier '=' namespace-or-type-name ';'
   using-namespace-directive  ::=  using namespace-name ';'
namespace-member-declarations ::=  namespace-member-declaration+
namespace-member-declaration  ::=  namespace-declaration | type-declaration
            type-declaration  ::=  ( class-declaration | struct-declaration | interface-declaration | enum-declaration |  delegate-declaration )
      qualified-alias-member  ::=  identifier "::" identifier type-argument-list?

//  AU.   Classes
class-declaration         ::=  ( attributes? class-modifiers? partial? class identifier type-parameter-list? )
	                           | ( class-base? type-parameter-constraints-clauses? class-body ';'? )
class-modifiers           ::=  class-modifier+
class-modifier            ::=  ( new | public | protected | internal | private | abstract | sealed | static )
class-base                ::=  ':' ( class-type | interface-type-list | ( class-type ',' interface-type-list ) )
class-body                ::=  '{'  class-member-declarations? '}'
class-member-declarations ::=  class-member-declaration+
class-member-declaration  ::=  (   constant-declaration |   field-declaration |   method-declaration  |    property-declaration
                                |       event-declaration | indexer-declaration | operator-declaration  | constructor-declaration
                                |  destructor-declaration |    type-declaration | static-constructor-declaration )
 // -- type parameter
 type-parameter-list ::= '<' type-parameters '>'
 type-parameters     ::=  type-attr-param ( ',' type-attr-param )*
 type-attr-param     ::=  attributes? type-parameter
 type-parameter      ::=  identifier
interface-type-list  ::=  interface-type ( ',' interface-type )*
// type parameter constraints
type-parameter-constraints-clauses ::= type-parameter-constraints-clause+
type-parameter-constraints-clause  ::= where type-parameter ':' type-parameter-constraints
type-parameter-constraints         ::= ( primary-constraint
                                        | ( secondary-constraints
                                        | ( constructor-constraint
                                        | ( primary-constraint    ','  secondary-constraints )
                                        | ( primary-constraint    ','  constructor-constraint )
                                        | ( secondary-constraints ','  constructor-constraint )
                                        | ( primary-constraint    ','  secondary-constraints ',' constructor-constraint )
                                       )
              primary-constraint   ::= ( class-type | class | struct )
            secondary-constraints  ::= ( interface-type | type-parameter | ( secondary-constraints ',' ( interface-type | type-parameter ) ) )
          constructor-constraint   ::=  new '(' ')'

// -- constant
constant-declaration  ::=  attributes? constant-modifiers? const type constant-declarators ';'
constant-modifiers    ::=  constant-modifier+
constant-modifier     ::=  ( new | public | protected | internal | private )
constant-declarators  ::=  constant-declarator ( ','  constant-declarator )*
constant-declarator   ::=  identifier '=' constant-expr

// == field
field-declaration     ::=  attributes? field-modifiers? type variable-declarators ';'
field-modifiers       ::=  field-modifier+
field-modifier        ::=  ( new | public | protected | internal | private | static | readonly | volatile )

// == variable
variable-declarators  ::=  variable-declarator ( ',' variable-declarator )*
variable-declarator   ::=  identifier ( '=' variable-initializer )?
variable-initializer  ::=  expr | array-initializer

// -- method
method-declaration  ::=  method-header method-body
method-header       ::=   ( attributes? method-modifiers? partial? return-type member-name type-parameter-list? )
                       | '(' formal-parameter-list? ')' type-parameter-constraints-clauses?
method-modifiers    ::=  method-modifier+
method-modifier     ::=  ( new | public | protected | internal | private | static | virtual | sealed | override | abstract | extern )
return-type         ::=  type | void
member-name         ::=  ( interface-type '.' )? identifier
method-body         ::=  block | ';'

formal-parameter-list ::=  ( fixed-parameters | ( fixed-parameters ',' parameter-array ) | parameter-array )
fixed-parameters      ::=  fixed-parameter ( ',' fixed-parameter )*
fixed-parameter       ::=  attributes? parameter-modifier? type identifier default-argument?
default-argument      ::=  '=' expr

// -- parameter
parameter-modifier    ::=  ( ref | out | this )
parameter-array       ::=  attributes? params array-type identifier

// -- property
property-declaration  ::=  attributes? property-modifiers? type member-name '{' accessor-declarations '}'
property-modifiers    ::=  property-modifier+
property-modifier     ::=  ( new | public | protected | internal | private | static | virtual | sealed | override | abstract | extern )
member-name           ::=  ( interface-type '.' )? identifier

// -- accessor
    accessor-declarations ::=  ( get-accessor-declaration set-accessor-declaration? ) | ( set-accessor-declaration get-accessor-declaration? )
get-accessor-declaration  ::=  attributes? accessor-modifier? get accessor-body
set-accessor-declaration  ::=  attributes? accessor-modifier? set accessor-body
    accessor-modifier     ::= ( protected | internal | private | protected internal | internal protected )
    accessor-body         ::=  block | ';'
// --
event-header       ::=  attributes? event-modifiers? event type
event-declaration  ::=  ( event-header ( variable-declarators ';' ) | ( member-name '{' event-accessor-declarations '}' )
event-modifiers    ::=  event-modifier+
event-modifier     ::=  ( new | public | protected | internal | private | static | virtual | sealed | override | abstract | extern )

 event-accessor-declarations  ::= ( add-accessor-declaration remove-accessor-declaration ) | ( remove-accessor-declaration add-accessor-declaration )
   add-accessor-declaration   ::=  attributes?   add  block
remove-accessor-declaration   ::=  attributes? remove block

// indexer
indexer-declaration  ::=  attributes? indexer-modifiers? indexer-declarator '{' accessor-declarations '}'
indexer-modifiers    ::=  indexer-modifier+
indexer-modifier     ::=  ( new | public | protected | internal | private | virtual | sealed | override | abstract | extern )
indexer-declarator   ::=  type ( interface-type '.')? this '[' formal-parameter-list ']'

// operator
operator-declaration  ::=  attributes? operator-modifiers operator-declarator operator-body
operator-body         ::=  block | ';'
operator-modifiers    ::=  operator-modifier+
operator-modifier     ::=  ( public | static | extern )
operator-declarator   ::=  ( unary-operator-declarator | binary-operator-declarator | conversion-operator-declarator )
     unary-operator-declarator  ::=  type operator overloadable-unary-operator '(' type identifier ')'
   overloadable-unary-operator  ::=  ( '+' | '-' | '!' | '~' | "++" | "--" | true | false )
    binary-operator-declarator  ::=  type operator overloadable-binary-operator '(' type identifier ',' type identifier ')'
  overloadable-binary-operator  ::=  ( '+' | '-' | '*' | '/' | '%' | '&' | '|' | '^' | "<<" | right-shift | "==" | "!=" | '>' | '<' | ">=" | "<=" )
                    imp-or-exp  ::=  implicit | explicit
conversion-operator-declarator  ::=  imp-or-exp operator type '(' type identifier ')'

// constructor
constructor-declaration ::=  attributes? constructor-modifiers? constructor-declarator constructor-body
constructor-modifiers   ::=  constructor-modifier+
constructor-modifier    ::=  ( public | protected | internal | private | extern )
constructor-declarator  ::=  identifier '(' formal-parameter-list? ')' constructor-initializer?
constructor-initializer ::=  ':'  ( base | this ) '('  argument-list?   ')'
constructor-body        ::=  block | ';'

// static constructor
static-constructor-declaration  ::=  attributes? static-constructor-modifiers identifier '(' ')' static-constructor-body
static-constructor-modifiers    ::=  ( extern? static ) | ( static extern? )
static-constructor-body         ::=  block | ';'

// destructor
destructor-declaration  ::=  attributes? extern? '~' identifier '(' ')' destructor-body
destructor-body         ::=  block | ';'


//  AV.   Structs

struct-declaration ::=  ( attributes? struct-modifiers? partial? struct identifier type-parameter-list? )
                      | ( struct-interfaces?  type-parameter-constraints-clauses? struct-body ';'? )
struct-modifiers   ::=  struct-modifier+
struct-modifier    ::=  ( new | public | protected | internal | private )
struct-interfaces  ::=  ':' interface-type-list
struct-body        ::=  '{' struct-member-declarations? '}'

struct-member-declarations ::=  struct-member-declaration+
struct-member-declaration  ::= (  constant-declaration |    field-declaration |   method-declaration | property-declaration
                                | event-declaration    | indexer-declaration  | operator-declaration | constructor-declaration
                                | type-declaration     | static-constructor-declaration )

//  AW.   Arrays
               array-type ::=  non-array-type rank-specifiers
           non-array-type ::=  type
          rank-specifiers ::=  rank-specifier+
          rank-specifier  ::=  '[' dim-separators? ']'
          dim-separators  ::=  ','+
        array-initializer ::=  ( '{' variable-initializer-list? '}' ) | ( '{' variable-initializer-list ',' '}' )
variable-initializer-list ::=  variable-initializer ( ',' variable-initializer )*
variable-initializer      ::=  expr | array-initializer

//  AX.   Interfaces

interface-declaration ::= ( ( attributes? interface-modifiers? partial? interface     )
                           | ( identifier variant-type-parameter-list? interface-base? )
                           | ( type-parameter-constraints-clauses? interface-body ';'? ) )
interface-modifiers   ::=  interface-modifier+
interface-modifier    ::=  ( new | public | protected | internal | private )

variant-type-parameter-list ::=  '<' variant-type-parameters '>'
variant-type-parameters     ::=  attr-vari-typeParam  ( ',' attr-vari-typeParam )*
attr-vari-typeParam         ::=  attributes?  variance-annotation?  type-parameter
variance-annotation         ::=  in | out

interface-base ::=  ':' interface-type-list
interface-body ::=  '{' interface-member-declarations? '}'

interface-member-declarations  ::=  interface-member-declaration+
interface-member-declaration   ::= ( interface-method-declaration | interface-property-declaration
                                    | interface-event-declaration | interface-indexer-declaration )
interface-method-declaration   ::=  ( attributes? new? return-type identifier type-parameter-list )
		                             | ( '(' formal-parameter-list? ')' type-parameter-constraints-clauses? ';' )
interface-property-declaration ::=  attributes? new? type identifier '{' interface-accessors '}'
interface-accessors            ::= (  ( attributes? ( get | set )  ';' )
                                    | ( attributes? get ';' attributes? set ';' )
                                    | ( attributes? set ';' attributes? get ';' ) )
interface-event-declaration    ::=  attributes? new? event type identifier ';'
interface-indexer-declaration  ::=  attributes? new? type this '[' formal-parameter-list ']' '{' interface-accessors '}'

//  AY.   Enums
enum-declaration ::=  attributes? enum-modifiers? enum identifier enum-base? enum-body ';'?
enum-base        ::=  ':' integral-type
enum-body        ::=  ( '{' enum-member-declarations? '}' ) | ( '{' enum-member-declarations ',' '}'
enum-modifiers   ::=  enum-modifier+
enum-modifier    ::=  ( new | public | protected | internal | private )

enum-member-declarations ::=  enum-member-declaration ( ','  enum-member-declaration)*
enum-member-declaration  ::=  attributes?   identifier ( '=' constant-expr )?

//  AZ.   Delegates
delegate-declaration ::= (  ( attributes? delegate-modifiers? delegate return-type )
	                        | ( identifier variant-type-parameter-list? )
                          | ( '(' formal-parameter-list? ')' type-parameter-constraints-clauses? ';' )
delegate-modifiers  ::=  delegate-modifier+
delegate-modifier   ::=  ( new | public | protected | internal | private )

//  BA.     Attributes
global-attributes         ::=  global-attribute-sections
global-attribute-sections ::=  global-attribute-section+
global-attribute-section  ::=  ( '[' global-attribute-target-specifier attribute-list ']' ) | ( '[' global-attribute-target-specifier attribute-list ',' ']' )

global-attribute-target-specifier  ::=  global-attribute-target ':'
global-attribute-target            ::=  assembly | module

        attributes         ::=  attribute-sections
        attribute-sections ::=  attribute-section+
        attribute-section  ::=  '[' attribute-target-specifier? attribute-list ','? ']' )

attribute-target-specifier ::=  attribute-target ':'
attribute-target           ::=  ( field | event | method | param | property | return | type )
attribute-list             ::=  attribute ( ',' attribute )?
attribute                  ::=  attribute-name attribute-arguments?
attribute-name             ::=  type-name
attribute-arguments        ::= ( ( '(' positional-argument-list? ')' )
                                | ( '(' positional-argument-list ',' named-argument-list ')' )
                                | ( '(' named-argument-list ')' )
                               )
positional-argument-list   ::=  positional-argument ( ',' positional-argument )*
positional-argument        ::=  argument-name?  attribute-argument-expr
named-argument-list        ::=  named-argument ( ',' named-argument )*
named-argument             ::=  identifier '=' attribute-argument-expr
attribute-argument-expr    ::=  expr
}


grammer:= CSharp_Unsafe <: CSharp_Grammar
{
//   BB.   Grammar extensions for unsafe code
      class-modifier  ::=  ... | unsafe
     struct-modifier  ::=  ... | unsafe
  interface-modifier  ::=  ... | unsafe
   delegate-modifier  ::=  ... | unsafe
      field-modifier  ::=  ... | unsafe
     method-modifier  ::=  ... | unsafe
   property-modifier  ::=  ... | unsafe
      event-modifier  ::=  ... | unsafe
    indexer-modifier  ::=  ... | unsafe
   operator-modifier  ::=  ... | unsafe
constructor-modifier  ::=  ... | unsafe

destructor-declaration ::=  ( attributes? extern? unsafe? '~' identifier '(' ')' destructor-body )
                          | ( attributes? unsafe? extern? '~' identifier '(' ')' destructor-body )

static-constructor-modifiers ::= (  ( extern? unsafe? static  ) | ( unsafe? extern?  static ) | ( extern?  static unsafe? )
                                  | ( unsafe? static  extern? ) | ( static  extern? unsafe? ) | ( static  unsafe? extern? )
                                 )
embedded-statement  ::= ( ... | unsafe-statement | fixed-statement )
  unsafe-statement  ::=  unsafe block
              type  ::= ( ... | pointer-type )
      pointer-type  ::=  ( unmanaged-type | void ) '*'
    unmanaged-type  ::=  type

primary-no-array-creation-expr ::=  ( ... | pointer-member-access | pointer-element-access | sizeof-expr )
                    unary-expr ::=  ( ... | pointer-indirection-expr | addressof-expr )
      pointer-indirection-expr ::=  '*' unary-expr
      pointer-member-access    ::=  primary-expr "->" identifier type-argument-list?
      pointer-element-access   ::=  primary-no-array-creation-expr '[' expr ']'
                addressof-expr ::=  '&' unary-expr
                   sizeof-expr ::=  sizeof '(' unmanaged-type ')'
     fixed-statement           ::=  fixed '(' pointer-type fixed-pointer-declarators ')' embedded-statement
     fixed-pointer-declarators ::=  fixed-pointer-declarator ( ',' fixed-pointer-declarator )*
     fixed-pointer-declarator  ::=  identifier '=' fixed-pointer-initializer
     fixed-pointer-initializer ::=  ( '&' variable-reference ) | expr
           buffer-element-type ::=     type
     struct-member-declaration ::=  ( '…' | fixed-size-buffer-declaration )
 fixed-size-buffer-declaration ::=  ( attributes? fixed-size-buffer-modifiers? fixed buffer-element-type ) |	( fixed-size-buffer-declarators ';' )
 fixed-size-buffer-modifiers   ::=  fixed-size-buffer-modifier+
 fixed-size-buffer-modifier    ::=  ( new | public | protected | internal | private | unsafe )
 fixed-size-buffer-declarators ::=  fixed-size-buffer-declarator+
 fixed-size-buffer-declarator  ::=  identifier '[' constant-expr ']'
   local-variable-initializer  ::=  ( '…' | stackalloc-initializer )
       stackalloc-initializer  ::=  stackalloc unmanaged-type '[' expr ']'
}